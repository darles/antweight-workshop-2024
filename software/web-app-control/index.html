<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Robot Tank Controller</title>
    <style>
        html, body {
            overscroll-behavior: none;
            touch-action: none;
            margin: 0;
            height: 100vh;
            background: black;
            font-family: monospace;
            color: white;
        }
        #debug {
            position: absolute;
            top: 1rem;
            left: 1rem;
            width: 40%;
            max-height: 90vh;
            overflow-y: auto;
            font-size: 14px;
            color: green;
        }
        #servo-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
        }
        #servo-controls input {
            writing-mode: vertical-lr;
            height: 60vh;
            margin-left: 60px;
        }
        #joystick-zone {
            position: absolute;
            width: 30vh;
            height: 30vh;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        @media screen and (orientation: landscape) {
            #joystick-zone {
                left: auto;
                right: 20px;
                transform: none;
            }
        }
        .buttons {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }
        .buttons > button {
            height: 2rem;
            padding: 0 5px;
            margin: 0 5px;
            font-size: large;
            font-weight: bold;
            background: black;
            color: #fff;
            cursor: pointer;
        }
        .invert-checkboxes {
            display: inline-block;
            color: orange;
            margin-right: 10px;
        }
        .cmd-status {
            display: inline-block;
            color: green;
            white-space: pre-wrap;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
</head>
<body>

<div id="debug"></div>

<div id="servo-controls">
    <input type="range" value="0" min="0" max="180" step="1" id="servo-left">
    <input type="range" value="0" min="0" max="180" step="1" id="servo-right">
</div>

<div id="joystick-zone"></div>

<div class="buttons">
    <span class="invert-checkboxes">
        Invert:
        <label><input id="invert-ml" type="checkbox">ML</label>
        <label><input id="invert-mr" type="checkbox">MR</label>
        <label><input id="invert-sl" type="checkbox">SL</label>
        <label><input id="invert-sr" type="checkbox">SR</label>
    </span>
    <span class="cmd-status">M0,0</span>
    <button disabled class="connect-btn btn" onclick="connectBLE()">Prisijungti</button>
</div>

<script>
    const cmdStatusEl = document.querySelector('.cmd-status');
    const connectBtn = document.querySelector('.connect-btn');
    const debugEl = document.getElementById('debug');
    const invertCheckboxes = {
        ML: document.getElementById('invert-ml'),
        MR: document.getElementById('invert-mr'),
        SL: document.getElementById('invert-sl'),
        SR: document.getElementById('invert-sr'),
    };

    class BLERobot {
        BLE_SERVICE_UUID = "99b96fd7-dd0e-49cd-b255-f7b692c3de5e";
        BLE_CHARACTERISTIC_UUID = "4fce1dff-9151-498f-aa72-581f3f9241f3";

        constructor() {
            this.name = '';
            this.left = 0;
            this.right = 0;
            this.servoLeft = 0;
            this.servoRight = 0;
            this.periodicReconnectTimer = null;
            this.encoder = new TextEncoder();
            this._connected = false;
            this._periodicSending();
        }

        async _connect() {
            const server = await this.device.gatt.connect();
            this.service = await server.getPrimaryService(this.BLE_SERVICE_UUID);
            this.characteristic = await this.service.getCharacteristic(this.BLE_CHARACTERISTIC_UUID);
            this.server = server;
            debugClear();
            debug(`Prisijungiau prie roboto „${this.device.name}“`);
            this.name = this.device.name;
            connectBtn.textContent = this.name;
            this._connected = true;
        }

        async _periodicReconnect(name) {
            if (name !== this.name) return;
            try {
                await this._connect();
            } catch (e) {
                if (name !== this.name) return;
                debug(`Nepavyko prisijungti prie roboto „${this.device.name}“, bandysiu vėl po 1s`);
                this.periodicReconnectTimer = setTimeout(() => this._periodicReconnect(name), 1000);
            }
        }

        async _periodicSending() {
            let delay = 0;
            try {
                if (!await this._send()) delay = 100;
            } catch (e) {
                debug('Klaida siunčiant komandą:', e);
            } finally {
                setTimeout(() => this._periodicSending(), delay);
            }
        }

        async connect() {
            try {
                clearTimeout(this.periodicReconnectTimer);
                this.device = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [this.BLE_SERVICE_UUID] }]
                });
                this.device.addEventListener('gattserverdisconnected', () => {
                    this._connected = false;
                    connectBtn.textContent = 'jungiamės...';
                    this._periodicReconnect(this.name);
                });
                await this._connect();
            } catch (e) {
                debug('Klaida jungiantis prie roboto:', e);
            }
        }

        get connected() {
            return this._connected && this.server?.connected;
        }

        disconnect() {
            clearTimeout(this.periodicReconnectTimer);
            connectBtn.textContent = 'Prisijungti';
            if (this.connected) this.server?.disconnect();
        }

        setSpeed(left, right) {
            this.left = localStorage.invertML ? left * -1 : left;
            this.right = localStorage.invertMR ? right * -1 : right;
        }

        setServoLeft(deg) {
            this.servoLeft = localStorage.invertSL ? (deg - 180) * -1 : deg;
        }

        setServoRight(deg) {
            this.servoRight = localStorage.invertSR ? (deg - 180) * -1 : deg;
        }

        async _send() {
            const cmd = `ML${this.left} MR${this.right} SL${this.servoLeft} SR${this.servoRight}`;
            const cmdStatus = `ML${this.left.toString().padStart(4, ' ')} MR${this.right.toString().padStart(4, ' ')} SL${this.servoLeft.toString().padStart(3, ' ')} SR${this.servoRight.toString().padStart(3, ' ')}`;
            cmdStatusEl.textContent = cmdStatus;

            if (this.connected) {
                const data = this.encoder.encode(cmd);
                await this.characteristic.writeValue(data);
                return true;
            }
            return false;
        }
    }

    function setupJoystick(robot) {
        const manager = nipplejs.create({
            zone: document.getElementById('joystick-zone'),
            mode: 'static',
            position: { right: '160px', bottom: '160px' },
            color: 'white',
            size: 300,
            restOpacity: 0.3,
        });

        manager.on('move', (evt, data) => {
            if (!data || !data.vector) return;

            const distance = Math.min(data.distance, 1); // limit max range
            const angle = data.angle.radian;
            let jx = Math.cos(angle) * distance;
            let jy = -Math.sin(angle) * distance; // invert Y manually

            // Reduce left/right sensitivity and cap output
            jx *= 0.5;
            const max = 0.8;
            const left = Math.round((jy + jx) * 255 * max);
            const right = Math.round((jy - jx) * 255 * max);

            robot.setSpeed(left, right);
        });

        manager.on('end', () => {
            robot.setSpeed(0, 0);
        });
    }

    function setupServoControl(robot) {
        const servoLeftEl = document.getElementById('servo-left');
        const servoRightEl = document.getElementById('servo-right');

        servoLeftEl.value = localStorage.servoLeft || 0;
        servoRightEl.value = localStorage.servoRight || 0;
        robot.setServoLeft(servoLeftEl.value);
        robot.setServoRight(servoRightEl.value);

        servoLeftEl.addEventListener('input', (e) => {
            robot.setServoLeft(e.target.value);
            localStorage.servoLeft = e.target.value;
        });
        servoRightEl.addEventListener('input', (e) => {
            robot.setServoRight(e.target.value);
            localStorage.servoRight = e.target.value;
        });
    }

    function setupInvertButtons() {
        function set(key, value) {
            if (value) localStorage[key] = 1;
            else delete localStorage[key];
        }
        for (let key in invertCheckboxes) {
            invertCheckboxes[key].checked = !!localStorage[`invert${key}`];
            invertCheckboxes[key].onclick = function () {
                set(`invert${key}`, this.checked);
            };
        }
    }

    function debug(...args) {
        const div = document.createElement('div');
        div.textContent = args.map(a => a === undefined ? 'undefined' : (a === null ? 'null' : a.valueOf())).join('  ');
        debugEl.insertBefore(div, debugEl.firstChild);
    }

    function debugClear() {
        debugEl.innerHTML = '';
    }

    async function checkRequirements() {
        if (!navigator.bluetooth) {
            debug("Jūsų naršyklė nepalaiko Bluetooth. Pabandykite su Google Chrome.");
            return;
        }
        if (!await navigator.bluetooth.getAvailability()) {
            debug("Nerastas Bluetooth įrenginys arba trūksta leidimo jį naudoti.");
            return;
        }
        connectBtn.disabled = false;
        debug("Labas! Spausk „Prisijungti“ ir prisijunk prie savo roboto.");
    }

    const robot = new BLERobot();

    function connectBLE() {
        if (robot.connected) robot.disconnect();
        robot.connect();
    }

    checkRequirements();
    setupServoControl(robot);
    setupJoystick(robot);
    setupInvertButtons();

    window.addEventListener("beforeunload", () => {
        robot.disconnect();
        debug('Bye bye');
    });
</script>
</body>
</html>
